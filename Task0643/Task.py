# Практически каждый уважающий себя программист знает, что для полного успеха зачастую мало
# написать программный продукт, его также успешно надо уметь продать, и тем более также успешно
# защитить от взлома, а соответственно и от несанкционированного распространения.
#
# Многие годы основным способом защиты программного обеспечения от незаконного распространения
# было использование, так называемого, активационного ключа. Вся проблема заключалась и заключается в том,
# что зачастую используется статический ключ, то есть активационный ключ для конкретного программного
# продукта не зависит ни от каких параметров и всегда является неизменным.
#
# Знаменитая компания "Gold&Silver Soft" решилась на революционный шаг – было решено разработать
# принципиально новый способ динамической генерации активационного ключа. В данном алгоритме ключ зависит
# от времени и меняется каждую минуту, что существенно затрудняет взлом.
#
# Будем считать, что активационным ключом является обычное целое положительное число. В данной версии
# алгоритма значение ключа на следующей минуте целиком и полностью зависит от значения ключа в текущий момент.
# Если в данный момент ключ равен N, то через минуту он будет равен N + S(N), где S(N) – это число, называемое
# контрольной суммой числа N и равняется количеству единиц в двоичной записи числа N. То есть если N = 6,
# то в следующую минуту значение ключа будет равно 8, если быть точнее, то
# N’ = N + S(N) = 6 + S(6) = 610 + S(1102) = 6 + 2 = 8.
#
# Будем считать, что на данный момент времени значение ключа равно N, вашей задачей является вычислить
# значение ключа через одну минуту.

n = int(input())
n_2 = bin(n)
s = 0
for i in range(len(n_2)):
    if n_2[i] == '1':
        s += 1
n = n + s
print(n)
